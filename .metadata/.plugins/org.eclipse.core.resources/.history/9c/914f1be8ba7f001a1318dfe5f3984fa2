/******************************************************************************
*
* Freescale Semiconductor Inc.
* (c) Copyright 2013-2020 Freescale Semiconductor, Inc.
* ALL RIGHTS RESERVED.
*
***************************************************************************//*!
*
* @file      lin_cfg.c
*
* @author    FPT Software
*
* @version   1.0
*
* @date      Thu Apr 16 16:17:54 CST 2020
*
* @brief     Common LIN configuration, data structure
*
******************************************************************************/
#include "lin_cfg.h"
#include "lin.h"
/* Mapping interface with hardware */
const lin_hardware_name lin_virtual_ifc[LIN_NUM_OF_IFCS] = {UART0};
/* Low level response buffer */
l_u8 lin_lld_response_buffer[LIN_NUM_OF_IFCS][10];
 /* Successful transfer flags */
l_u8 lin_successful_transfer[LIN_NUM_OF_IFCS];
/* Error in response */
l_u8 lin_error_in_response[LIN_NUM_OF_IFCS];
/* Goto sleep flag */
l_u8 lin_goto_sleep_flg[LIN_NUM_OF_IFCS];
/* Save configuration flag */
l_u8 lin_save_configuration_flg[LIN_NUM_OF_IFCS] = {0};
 /* Next transmit tick */
l_u8 lin_next_transmit[LIN_NUM_OF_IFCS];
 /* lin word status */
lin_word_status_str lin_word_status[LIN_NUM_OF_IFCS];
/* current pid */
l_u8 lin_current_pid[LIN_NUM_OF_IFCS];

/* definition and initialization of signal array */
l_u8    lin_pFrameBuf[LIN_FRAME_BUF_SIZE] =
{


  0x80 /* 0 : 10000000 */ /* start of frame LI0_BCM_01 */

  ,0xf8 /* 1 : 11111000 */
  ,0x00 /* 2 : 00000000 */
  ,0x00 /* 3 : 00000000 */
  ,0x00 /* 4 : 00000000 */
  ,0x00 /* 5 : 00000000 */
  ,0xff /* 6 : 11111111 */
  ,0xff /* 7 : 11111111 */


  ,0x00 /* 8 : 00000000 */ /* start of frame LI0_RLS_01 */

  ,0xfe /* 9 : 11111110 */
  
  ,0x00 /* 10 : 00000000 */
  
  ,0xf0 /* 11 : 11110000 */
  
  ,0x00 /* 12 : 00000000 */
  
  ,0xf0 /* 13 : 11110000 */
  
  ,0xff /* 14 : 11111111 */
  
  ,0xff /* 15 : 11111111 */
  

  ,0xfe /* 16 : 11111110 */ /* start of frame LI0_RLS_02 */

  ,0xfe /* 17 : 11111110 */
  
  ,0xff /* 18 : 11111111 */
  
  ,0xff /* 19 : 11111111 */
  
  ,0xff /* 20 : 11111111 */
  
  ,0xff /* 21 : 11111111 */
  
  ,0xff /* 22 : 11111111 */
  
  ,0xff /* 23 : 11111111 */
  
};

/* definition and initialization of signal array */
l_u8    lin_flag_handle_tbl[LIN_FLAG_BUF_SIZE] =
{


  0x00 /* 0: start of flag frame LI0_BCM_01 */

  ,0x00 /* 1: */


  ,0x00 /* 2: start of flag frame LI0_RLS_01 */

  ,0x00 /* 3: */
  

  ,0x00 /* 4: start of flag frame LI0_RLS_02 */

};

/*************************** Flag set when signal is updated ******************/
/* Diagnostic signal */
l_u8 lin_diag_signal_tbl[LIN_NUM_OF_IFCS][16];
/*****************************event trigger frame*****************************/
/* all event trigger frames for master node */


/*****************************sporadic frame*****************************/
/*all sporadic frames for master node*/
/**********************************  Frame table **********************************/
const lin_frame_struct lin_frame_tbl[LIN_NUM_OF_FRMS] ={

    { LIN_FRM_UNCD, 8, LIN_RES_PUB, 0, 0, 2   , (l_u8*)0 }

   ,{ LIN_FRM_UNCD, 8, LIN_RES_SUB, 8, 2, 2 , (l_u8*)0 }
  
   ,{ LIN_FRM_UNCD, 8, LIN_RES_SUB, 16, 4, 1 , (l_u8*)0 }
  
   ,{ LIN_FRM_DIAG, 8, LIN_RES_PUB, 0, 0, 0 , (l_u8*)0 }
  
   ,{ LIN_FRM_DIAG, 8, LIN_RES_SUB, 0, 0, 0 , (l_u8*)0 }
  
};

/*********************************** Frame flag Initialization **********************/
l_bool lin_frame_flag_tbl[LIN_NUM_OF_FRMS] = {0, 0, 0, 0, 0};

/**************************** Lin configuration Initialization ***********************/
/* max_response_frame_timeout = round((1.4x(10+Nx10)xTbit)/Tbase_period) + 3 */
const l_u16 lin_max_frame_res_timeout_val[LIN_NUM_OF_IFCS][8]= {

   {6, 7, 9, 10, 12, 13, 15, 16 }
  
};


l_u8 LI0_lin_configuration_RAM[LI0_LIN_SIZE_OF_CFG]= {0x00, 0x10, 0x20, 0x21, 0x3C, 0x3D ,0xFF};


const l_u16  LI0_lin_configuration_ROM[LI0_LIN_SIZE_OF_CFG]= {0x0000, 0x10, 0x20, 0x21, 0x3C, 0x3D ,0xFFFF};

/**************** Node attributes Initialization  ****************************/





/********************** Go to sleep Initialization *************************/
const lin_schedule_data LI0_lin_gotosleep_data[1] = {
   {LI0_MasterReq, 15, {0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}}
};


/******************** Schedule table Initialization ************************/
const lin_schedule_data LI0_NormalTable_data[3] = {

   {LI0_BCM_01, 2, 0}
  

   , {LI0_RLS_01, 5, 0}
  
   , {LI0_RLS_02, 2, 0}
  
};

/******************** Schedule table Initialization ************************/
const lin_schedule_data LI0_DiagReqNormalTable_data[4] = {

   {LI0_MasterReq, 2, 0}
  

   , {LI0_BCM_01, 2, 0}
  
   , {LI0_RLS_01, 5, 0}
  
   , {LI0_RLS_02, 2, 0}
  
};

/******************** Schedule table Initialization ************************/
const lin_schedule_data LI0_DiagRespNormalTable_data[4] = {

   {LI0_SlaveResp, 2, 0}
  

   , {LI0_BCM_01, 2, 0}
  
   , {LI0_RLS_01, 5, 0}
  
   , {LI0_RLS_02, 2, 0}
  
};

/******************** Schedule table Initialization ************************/
const lin_schedule_data LI0_DiagReqOnly_data[1] = {

   {LI0_MasterReq, 2, 0}
  
};

/******************** Schedule table Initialization ************************/
const lin_schedule_data LI0_DiagRespOnly_data[1] = {

   {LI0_SlaveResp, 2, 0}
  
};



/********************* Schedule table structure Initialization ***************/
const lin_schedule_struct lin_schedule_tbl[LIN_NUM_OF_SCHD_TBL] ={

   /*interface_name = LI0 */
   {0, LIN_SCH_TBL_NULL  ,(lin_schedule_data*)0 }
  

   ,{1, LIN_SCH_TBL_GOTO  , &LI0_lin_gotosleep_data[0] }
  
   ,{3, LIN_SCH_TBL_NORM  , &LI0_NormalTable_data[0] }
  
   ,{4, LIN_SCH_TBL_NORM  , &LI0_DiagReqNormalTable_data[0] }
  
   ,{4, LIN_SCH_TBL_NORM  , &LI0_DiagRespNormalTable_data[0] }
  
   ,{1, LIN_SCH_TBL_DIAG  , &LI0_DiagReqOnly_data[0] }
  
   ,{1, LIN_SCH_TBL_DIAG  , &LI0_DiagRespOnly_data[0] }
  
};
/********************** Schedule table status Initialization ******************/
l_u8 lin_schedule_start_entry[LIN_NUM_OF_SCHD_TBL] = {0, 0, 0, 0, 0, 0, 0};
l_u8 lin_active_schedule_id[LIN_NUM_OF_IFCS] = {0};
l_u8 lin_previous_schedule_id[LIN_NUM_OF_IFCS] = {0};



lin_diagnostic_state diagnostic_state[LIN_NUM_OF_IFCS] = {
   LD_DIAG_IDLE 
};
l_u8 lin_diag_frame_to_send[LIN_NUM_OF_IFCS] = {0};

lin_service_status   service_status[LIN_NUM_OF_IFCS]   = {
   LD_SERVICE_IDLE 
};
l_diagnostic_mode diag_mode[LIN_NUM_OF_IFCS] = {DIAG_NONE};



lin_tl_pdu_data LI0_tl_tx_queue_data[MAX_QUEUE_SIZE];
lin_tl_pdu_data LI0_tl_rx_queue_data[MAX_QUEUE_SIZE];



lin_transport_layer_queue lin_tl_tx_queue[LIN_NUM_OF_IFCS] = {

   { 0, 0, LD_QUEUE_EMPTY, 0, MAX_QUEUE_SIZE, LI0_tl_tx_queue_data }

};
lin_transport_layer_queue lin_tl_rx_queue[LIN_NUM_OF_IFCS] = {

   { 0, 0, LD_QUEUE_EMPTY, 0, MAX_QUEUE_SIZE, LI0_tl_rx_queue_data }

};
/* diagnostic interleaved mode */
diag_interleaved_state lin_diag_interleaved_state[LIN_NUM_OF_IFCS] = { DIAG_NOT_START };

/****************************Support SID Initialization ***********************/

const l_u8 LI0_lin_diag_services_supported[_LI0_DIAG_NUMBER_OF_SERVICES_] = {0xB2,0xB7,0x22,0xB3,0xB0,0x2E,0xB6,0xB4};
l_u8 LI0_lin_diag_services_flag[_LI0_DIAG_NUMBER_OF_SERVICES_] = {0,0,0,0,0,0,0,0};


/****************************Transport Layer Initialization ***********************/

lin_tl_descriptor lin_tl_desc[LIN_NUM_OF_IFCS] = {

   /* interface_name = LI0 */
   {
   &lin_tl_tx_queue[LI0],          /* *pointer to transmit queue on TL */
   &lin_tl_rx_queue[LI0],          /* *pointer to receive queue on TL */

   /* Declaration only for Master interface */
   /* message in transmit queue */
   LD_COMPLETED,           /* status of message in transmit queue */
   0,                /* index of message in queue */
   0,                /* Size of message in queue */
   /* message in receive queue */
   LD_NO_MSG,            /* status of receiving message */
   LD_COMPLETED,           /* status of message in transmit queue */
   0,                /* index of message in queue */
   0,                /* Size of message in queue */
   LD_SUCCESS,           /* Status of the last configuration service in LIN 2.0, J2602 */
   0,                /* RSID of the last node configuration service */
   0,                /* Error code in case of positive response */
   0,                /* number of received pdu */
   0,                /* frame counter in received message */
   LD_NO_CHECK_TIMEOUT,            /* timeout type */
   0,
   /* Declaration only for Slave interface */
   (l_u8*)0,
   0,                   /* Slave Response data counter */
   _LI0_DIAG_NUMBER_OF_SERVICES_,
   (l_u8*) &LI0_lin_diag_services_supported,
   (l_u8*) &LI0_lin_diag_services_flag,           /* diagnostic services flags*/
   0           /* Interleaved time out counter */
   }

};

/****************************LIN interface configuration ****************************/
const lin_configuration lin_ifc_configuration[LIN_NUM_OF_IFCS] = {

   /* Interface_name = LI0 */
   {
   LIN_PROTOCOL_21,         /*lin_protocol_version */
   LIN_PROTOCOL_21,         /*lin_language_version */
   19200,            /*  baud_rate */
   _MASTER_,                 /*  function _SLAVE_ | _MASTER_*/
   0,                        /*  node attribute is only used for slave node*/
   /* LIN data pointer */
   &lin_lld_response_buffer[LI0][0],        /*  *response_buffer */
   &lin_successful_transfer[LI0],           /*  *lin_successful_transfer */
   &lin_error_in_response[LI0],             /*  *lin_error_in_response */
   &lin_goto_sleep_flg[LI0],              /*  *goto_sleep_flg */
   &lin_current_pid[LI0],                 /*  *current_pid */
   &lin_word_status[LI0],                 /*  *word_status */
   /* Protocol */
   10,                          /*  2*timebase */
   &lin_diag_signal_tbl[LI0][0],          /*  *diag_signal_tbl */
   5,                            /*  num_of_frames */
   0,                              /*  frame_start */
   &lin_frame_tbl[0],                                          /*  frame_tbl */
   &lin_frame_flag_tbl[0],                                       /*  *frame_flg */

   7,                     /*  num_of_schedules */
   0,                       /*  schedule_start */
   &lin_schedule_tbl[0],                                   /*  schedule_tbl */
   &lin_schedule_start_entry[0],                             /*  schedule_start_entry */
   &lin_next_transmit[LI0],             /*  next_transmit_tick */
   &lin_active_schedule_id[LI0],          /*  active_schedule_id */
   &lin_previous_schedule_id[LI0],        /*  previous_schedule_id */
   &lin_diag_frame_to_send[LI0],          /*  *diagnostic_frame_to_send */
   &diag_mode[LI0],                   /*  diagnostic_mode */
   &LI0_lin_configuration_RAM[0],       /*  *configuration_RAM */
   &LI0_lin_configuration_ROM[0],       /*  *configuration_ROM */
   &lin_tl_desc[LI0],
   &diagnostic_state[LI0],
   &service_status[LI0],
   &lin_diag_interleaved_state[LI0]
   }

};
/*************************** Node hardware configuration definition *************************/
/* Node hardware configuration */
lin_node lin_node_descrs[NUM_OF_UART_CHANNEL]={
   {(tUART*)UART0_ADDR, 0, 0xFF, UNINIT,  0, 0,(l_u8*)0, 0x00, (l_u8*)0, 0x80, 0, 0, 0, 0 },
   {(tUART*)UART1_ADDR, 0, 0xFF, UNINIT,  0, 0,(l_u8*)0, 0x00, (l_u8*)0, 0x80, 0, 0, 0, 0 },
   {(tUART*)UART2_ADDR, 0, 0xFF, UNINIT,  0, 0,(l_u8*)0, 0x00, (l_u8*)0, 0x80, 0, 0, 0, 0 }
};


/* This function is an example of response; real implementation is application-dependent */
/* You can use one of the following define to set PCI of response frame for */
/* this service to the correct value */
l_u8 ld_read_by_id_callout(l_ifc_handle iii, l_u8 id, l_u8 *data){
	(void) iii;
	(void) id;
	(void) data;
	return LD_ID_NO_RESPONSE;
}